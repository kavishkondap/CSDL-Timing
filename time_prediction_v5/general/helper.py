import math
from csdl.rep.operation_node import OperationNode
from pkg_resources import resource_filename
import os
from fnmatch import fnmatch
from importlib import import_module
from time_prediction_v5.data_collection.operation import Operation

def checkValidity (op:Operation, rep):
    """
    checkValidity ensures that the operation-specific CSDL model is correctly written and compiled by checking two properties:
    - num_iter: the num_iter value defined in the operation file should be equivalent to the total amount of operartions in the model
    - op_name: every operation in the graph should be the same, and all should be equivalent to the operation being tested

    If either of these requirements aren't satisfied, an error is thrown

    `Parameters`:
    - num_iter (int): the num_iter value defined in the operation-specific file
    - op_name (str): the name of the operation being checked
    - rep (CSDL Graph Representation): the graph representation of the model being analyzed

    `Returns`:
    - validity (bool): the validity of the rep passed in. If False, an error is thrown.
  
    """
    validity = True
    graph = rep.flat_graph
    total_operations = 0
    for node in graph:
        if isinstance (node, OperationNode):
            empirical_op_name = str(node.op).split ()[0].split('.')[-1]
            if not empirical_op_name==op.source_node:
                validity = False
            total_operations+=1
    if not (total_operations==op.num_iter):
        validity = False
    # print (op_name, validity)
    if not validity:
        raise TypeError (f'Incorrect num_iterations ({op.num_iter} expected vs {total_operations} recieved) or op_type ({op.op_name} expected vs {empirical_op_name} recieved)')
    return validity

def checkData (op_dict, data):
    """
    Checks the data produced by a time_operation call, ensuring that the expected amount of data was collected, and throws an error
    otherwise.

    `Parameters`:
    - master_dict (dict): the master_dict generated by the get_master_dict function in time_prediction_v5/general/constants
    - to_include (str or list): Either 'all', or a list of parameters to include in the dictionary

    `Returns`:
    - new_dict (dict): the filtered dictionary of master_dict

    """
    expected_len = 1
    for key in op_dict.keys ():
        expected_len *=len (op_dict[key]['values'])
    empirical_len = len (data ['times'])
    if not (expected_len  == empirical_len):
        raise ValueError (f'Incorrect data length recieved ({expected_len} expected vs {empirical_len} recieved)')
def filterOps (ops, to_include):
    """
    A function that removed unwanted keys/values from the master_dict. If to_include = 'all', all keys/values are kept. Otherwise only the keys
    cited in the to_include variable are kept.

    `Parameters`:
    - master_dict (dict): the master_dict generated by the get_master_dict function in time_prediction_v5/general/constants
    - to_include (str or list): Either 'all', or a list of parameters to include in the dictionary

    `Returns`:
    - new_dict (dict): the filtered dictionary of master_dict

    """
    if (type (to_include) == str and to_include=='all'):
        return ops
    else:
        filtered_ops = {}
        for op in ops.values ():
            if (op.op_name in to_include):
                filtered_ops [op.op_name] = op
        return filtered_ops

# def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = 'â–ˆ', printEnd = "\r"):
#     """
#     Call in a loop to create terminal progress bar
#     @params:
#         iteration   - Required  : current iteration (Int)
#         total       - Required  : total iterations (Int)
#         prefix      - Optional  : prefix string (Str)
#         suffix      - Optional  : suffix string (Str)
#         decimals    - Optional  : positive number of decimals in percent complete (Int)
#         length      - Optional  : character length of bar (Int)
#         fill        - Optional  : bar fill character (Str)
#         printEnd    - Optional  : end character (e.g. "\r", "\r\n") (Str)
#     """
#     percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
#     filledLength = int(length * iteration // total)
#     bar = fill * filledLength + '-' * (length - filledLength)
#     print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
#     # Print New Line on Complete
#     if iteration == total: 
#         print()